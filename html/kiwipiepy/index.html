<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>kiwipiepy API documentation</title>
<meta name="description" content="Kiwipiepy란?
Kiwipiepy는 한국어 형태소 분석기인 Kiwi(Korean Intelligent Word Identifier)의 Python 모듈입니다.
C++로 작성되었고 다른 패키지에 의존성이 없으므로 C++ 컴파일이 가능한 환경이라면 어디에서나 …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kiwipiepy</code></h1>
</header>
<section id="section-intro">
<h1 id="kiwipiepy">Kiwipiepy란?</h1>
<p>Kiwipiepy는 한국어 형태소 분석기인 Kiwi(Korean Intelligent Word Identifier)의 Python 모듈입니다.
C++로 작성되었고 다른 패키지에 의존성이 없으므로 C++ 컴파일이 가능한 환경이라면 어디에서나 Kiwipiepy를 사용 가능합니다.</p>
<p>현재 Kiwipiepy의 최신 버전은 0.8.0입니다.</p>
<p><img alt="" src="https://badge.fury.io/py/kiwipiepy.svg"></p>
<h2 id="_1">시작하기</h2>
<p>pip를 이용해 쉽게 설치할 수 있습니다. (<a href="https://pypi.org/project/kiwipiepy/">https://pypi.org/project/kiwipiepy/</a>)</p>
<p>::</p>
<pre><code>$ pip install kiwipiepy
</code></pre>
<p>지원하는 OS와 Python 버전은 다음과 같습니다:</p>
<ul>
<li>Python 3.5 이상이 설치된 Linux (x86-64) </li>
<li>Python 3.5 이상이 설치된 macOS 10.13이나 그 이후 버전</li>
<li>Python 3.5 이상이 설치된 Windows 7 이나 그 이후 버전 (x86, x86-64)</li>
<li>Python 3.5 이상이 설치된 다른 OS: 이 경우 소스 코드 컴파일을 위해 C++11이 지원되는 컴파일러가 필요합니다.</li>
</ul>
<p>Kiwipiepy가 제대로 설치되었는지 확인하기 위해서는 다음 명령어를 실행해보십시오.</p>
<p>::</p>
<pre><code>$ python -m kiwipiepy
</code></pre>
<p>위 명령어는 대화형 인터페이스를 시작합니다. 인터페이스에 원하는 문장을 입력하면 형태소 분석 결과를 확인할 수 있습니다.</p>
<p>::</p>
<pre><code>&gt;&gt; 안녕?
[('안녕', 'IC', 0, 2), ('?', 'SF', 2, 3)]
</code></pre>
<p>인터페이스를 종료하려면 Ctrl + C 를 누르십시오.</p>
<h2 id="_2">예제</h2>
<p><strong> 간단한 분석 </strong></p>
<p>다음 예제 코드는 kiwipiepy 인스턴스를 생성해 형태소 분석을 수행하는 간단한 예제 코드입니다.</p>
<p>::</p>
<pre><code>from kiwipiepy import Kiwi
kiwi = Kiwi()
kiwi.prepare()
for result, score in kiwi.analyze("형태소 분석 결과입니다", top_n=5):
    print(score, result, sep='\t')

# 위 코드를 실행하면 다음과 같은 결과가 나옵니다.
# -34.40869140625   [('형태소', 'NNG', 0, 3), ('분석', 'NNG', 4, 2), ('결과', 'NNG', 7, 2), ('이', 'VCP', 9, 1), ('ᆸ니다', 'EF', 10, 2)]
# -41.41796875  [('형태소', 'NNG', 0, 3), ('분석', 'NNG', 4, 2), ('결과', 'NNG', 7, 2), ('이', 'MM', 9, 1), ('ᆸ니다', 'EF', 10, 2)]
# -54.265869140625  [('형태소', 'NNG', 0, 3), ('분석', 'NNG', 4, 2), ('결과', 'NNG', 7, 2), ('입', 'NNG', 9, 1), ('니', 'EC', 10, 1), ('다', 'EC', 11, 1)]
# -54.470458984375  [('형태소', 'NNG', 0, 3), ('분석', 'NNG', 4, 2), ('결과', 'NNG', 7, 2), ('입', 'NNG', 9, 1), ('니다', 'EF', 10, 2)]
# -54.705078125 [('형태소', 'NNG', 0, 3), ('분석', 'NNG', 4, 2), ('결과', 'NNG', 7, 2), ('입', 'NNG', 9, 1), ('이', 'VCP', 10, 1), ('니', 'EC', 10, 1), ('다', 'EC', 11, 1)]
</code></pre>
<p><strong> 사용자 단어 추가 </strong></p>
<p>사용자 정의 단어를 추가하여 형태소 분석을 수행하는 예제입니다. 사용자 정의 단어를 등록하면 이는 Kiwi 분석기의 사전에 포함되어 결과의 후보로 등장할 수 있게 됩니다.</p>
<p>종종 동일한 형태의 단어가 여러 가지로 분석되는 경우가 있습니다. 이 경우 사용자 정의 단어를 우선할지, 분석기가 가지고 있는 형태소 정보를 우선할지 사용자 단어 점수를 조절함으로써 통제 가능합니다.
아래 예제는 '골리'라는 고유 명사 단어가 포함된 문장을 분석하는 경우에 부여하는 단어 점수에 따라 결과가 어떻게 달라지는지를 보여줍니다.</p>
<p>::</p>
<pre><code>from kiwipiepy import Kiwi

# 사용자 단어 추가 없이 분석해보겠습니다.

kiwi = Kiwi()
kiwi.prepare()

print(*kiwi.analyze('사람을 골리다', top_n=5), sep='\n')
# 결과
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'VV', 4, 2), ('다', 'EC', 6, 1)], -36.505615234375)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'VV', 4, 2), ('다', 'MAG', 6, 1)], -40.310791015625)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'VV', 4, 2), ('하', 'XSA', 6, 1), ('다', 'EC', 6, 1)], -40.388427734375)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'VV', 4, 2), ('하', 'XSV', 6, 1), ('다', 'EC', 6, 1)], -42.22119140625)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'VV', 4, 2), ('다', 'EF', 6, 1)], -42.44189453125)

print(*kiwi.analyze('골리는 사람이다', top_n=5), sep='\n')
# 결과
# ([('골리', 'VV', 0, 2), ('는', 'ETM', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EC', 7, 1)], -39.06201171875)
# ([('골리', 'VV', 0, 2), ('는', 'ETM', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EF', 7, 1)], -41.10693359375)
# ([('골리', 'VV', 0, 2), ('는', 'ETM', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'JKS', 6, 1), ('다', 'MAG', 7, 1)], -41.588623046875)
# ([('골리', 'VV', 0, 2), ('는', 'JX', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EC', 7, 1)], -41.6220703125)
# ([('골리', 'VV', 0, 2), ('는', 'JX', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'JKS', 6, 1), ('다', 'MAG', 7, 1)], -43.114990234375)

# 사용자 단어 '골리'를 추가해보도록 하겠습니다.
kiwi = Kiwi()
kiwi.add_user_word('골리', 'NNP', 0)
kiwi.prepare()

print(*kiwi.analyze('사람을 골리다', top_n=5), sep='\n')
# 결과
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'NNP', 4, 2), ('다', 'EC', 6, 1)], -31.064453125)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'NNP', 4, 2), ('다', 'MAG', 6, 1)], -34.109619140625)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'NNP', 4, 2), ('다', 'EF', 6, 1)], -37.097900390625)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골', 'NNG', 4, 1), ('리다', 'EF', 5, 2)], -45.919189453125)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골', 'VV', 4, 1), ('리다', 'EF', 5, 2)], -49.18359375)

print(*kiwi.analyze('골리는 사람이다', top_n=5), sep='\n')
# 결과
# ([('골리', 'NNP', 0, 2), ('는', 'JX', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EC', 7, 1)], -25.12841796875)
# ([('골리', 'NNP', 0, 2), ('는', 'JX', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'JKS', 6, 1), ('다', 'MAG', 7, 1)], -26.621337890625)
# ([('골리', 'NNP', 0, 2), ('는', 'JX', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EF', 7, 1)], -27.17333984375)
# ([('골리', 'NNP', 0, 2), ('는', 'ETM', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EC', 7, 1)], -29.90185546875)
# ([('골리', 'NNP', 0, 2), ('는', 'ETM', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EF', 7, 1)], -31.94677734375)

# 사용자 단어 '골리'의 점수를 낮춰서 추가해보도록 하겠습니다.
kiwi = Kiwi()
kiwi.add_user_word('골리', 'NNP', -6)
kiwi.prepare()

print(*kiwi.analyze('사람을 골리다', top_n=5), sep='\n')
# 결과
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'VV', 4, 2), ('다', 'EC', 6, 1)], -36.505615234375)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'NNP', 4, 2), ('다', 'EC', 6, 1)], -37.064453125)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'NNP', 4, 2), ('다', 'MAG', 6, 1)], -40.109619140625)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'VV', 4, 2), ('다', 'MAG', 6, 1)], -40.310791015625)
# ([('사람', 'NNG', 0, 2), ('을', 'JKO', 2, 1), ('골리', 'VV', 4, 2), ('다', 'EF', 6, 1)], -42.44189453125)

print(*kiwi.analyze('골리는 사람이다', top_n=5), sep='\n')    
# 결과
# ([('골리', 'NNP', 0, 2), ('는', 'JX', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EC', 7, 1)], -31.12841796875)
# ([('골리', 'NNP', 0, 2), ('는', 'JX', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'JKS', 6, 1), ('다', 'MAG', 7, 1)], -32.621337890625)
# ([('골리', 'NNP', 0, 2), ('는', 'JX', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EF', 7, 1)], -33.17333984375)
# ([('골리', 'NNP', 0, 2), ('는', 'ETM', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EC', 7, 1)], -35.90185546875)
# ([('골리', 'NNP', 0, 2), ('는', 'ETM', 2, 1), ('사람', 'NNG', 4, 2), ('이', 'VCP', 6, 1), ('다', 'EF', 7, 1)], -37.94677734375)
</code></pre>
<p><strong> 멀티스레딩 analyze </strong></p>
<p>다음 예제 코드는 <code>test.txt</code> 파일을 줄별로 읽어들여 형태소 분석한 뒤 그 결과를 <code>result.txt</code>에 저장합니다.</p>
<p>::</p>
<pre><code>from kiwipiepy import Kiwi

class IOHandler:
    def __init__(self, input, output):
        self.input = open(input, encoding='utf-8')
        self.output = open(output, 'w', encoding='utf-8')

    def read(self, sent_id):
        if sent_id == 0:
            self.input.seek(0)
            self.iter = iter(self.input)
        try:
            return next(self.iter)
        except StopIteration:
            return None

    def write(self, sent_id, res):
        print('Analyzed %dth row' % sent_id)
        self.output.write(' '.join(map(lambda x:x[0]+'/'+x[1], res[0][0])) + '\n')

    def __del__(self):
        self.input.close()
        self.output.close()

kiwi = Kiwi()
kiwi.load_user_dictionary('userDict.txt')
kiwi.prepare()
handle = IOHandler('test.txt', 'result.txt')
kiwi.analyze(handle.read, handle.write)
</code></pre>
<h2 id="_3">사용자 정의 사전 포맷</h2>
<p>사용자 정의 사전은 UTF-8로 인코딩된 텍스트 파일이어야 하며, 다음과 같은 구조를 띄어야 합니다.</p>
<pre><code>#주석은 #으로 시작합니다.

단어1 [탭문자] 품사태그 [탭문자] 단어점수

단어2 [탭문자] 품사태그 [탭문자] 단어점수

단어3 [탭문자] 품사태그 [탭문자] 단어점수
</code></pre>
<p>단어점수는 생략 가능하며, 생략 시 기본값인 0으로 처리됩니다.</p>
<h2 id="_4">데모</h2>
<p><a href="https://lab.bab2min.pe.kr/kiwi">https://lab.bab2min.pe.kr/kiwi</a> 에서 데모를 실행해 볼 수 있습니다.</p>
<h2 id="_5">라이센스</h2>
<p>Kiwi는 LGPL v3 라이센스로 배포됩니다.</p>
<h2 id="_6">오류 제보</h2>
<p>Kiwipiepy 사용 중 오류 발생시 깃헙 이슈탭을 통해 제보해주세요.</p>
<p>Python 모듈 관련 오류는
<a href="https://github.com/bab2min/kiwipiepy/issues,">https://github.com/bab2min/kiwipiepy/issues,</a> 형태소 분석기 전반에 대한 오류는 <a href="https://github.com/bab2min/kiwi/issues">https://github.com/bab2min/kiwi/issues</a> 에 올려주시면 감사하겠습니다.</p>
<h2 id="_7">역사</h2>
<ul>
<li>
<p>0.8.0 (2020-03-29)</p>
<ul>
<li>URL, 이메일, 해시태그를 검출하는 기능이 추가되었습니다. <code>analyze</code> 메소드의 <code>match_options</code> 파라미터로 이 기능의 사용 유무를 설정할 수 있습니다.</li>
<li>치(하지), 컨대(하건대), 토록(하도록), 케(하게) 축약형이 포함된 동사 활용형을 제대로 분석하지 못하는 문제를 해결했습니다.</li>
<li>사용자 사전에 알파벳이나 숫자, 특수 기호가 포함된 단어가 있을 때, 형태소 분석시 알파벳, 숫자, 특수 기호가 포함된 문장이 제대로 분석되지 않는 문제를 수정했습니다.</li>
<li>사용자 사전에 형태는 같으나 품사가 다른 단어를 등록할 수 없는 제한을 해제하였습니다.</li>
</ul>
</li>
<li>
<p>0.7.6 (2020-03-24)</p>
<ul>
<li><code>async_analyze</code> 메소드가 추가되었습니다. 이 메소드는 형태소 분석을 비동기로 처리합니다. 처리 결과는 callable인 리턴값을 호출하여 얻을 수 있습니다.</li>
<li>U+10000 이상의 유니코드 문자에 대해 형태소 분석 결과의 위치 및 길이가 부정확하게 나오는 문제를 해결했습니다.</li>
</ul>
</li>
<li>
<p>0.7.5 (2020-03-04)</p>
<ul>
<li>U+10000 이상의 문자를 입력시 extract 계열 함수에서 종종 오류가 발생하던 문제를 해결했습니다.</li>
<li>gcc 4.8 환경 및 manylinux 대한 지원을 추가했습니다.</li>
</ul>
</li>
<li>
<p>0.7.4 (2019-12-30)</p>
<ul>
<li>reader, receiver를 사용하는 함수 계열에서 메모리 누수가 발생하던 문제를 해결했습니다.</li>
<li>문서 내 reader, receiver의 사용법 내의 오류를 적절하게 수정했습니다.</li>
<li>종종 분석 결과에서 빈 /UN 태그가 등장하는 문제를 수정했습니다.</li>
<li>일부 특수문자를 분석하는데 실패하는 오류를 수정했습니다.</li>
</ul>
</li>
<li>
<p>0.7.3 (2019-12-15)</p>
<ul>
<li>macOS 환경에서 extract 계열 함수를 호출할때 스레드 관련 오류가 발생하는 문제를 해결했습니다.</li>
</ul>
</li>
<li>
<p>0.7.2 (2019-12-01)</p>
</li>
<li>
<p>0.7.1 (2019-09-23)</p>
<ul>
<li>사전 로딩 속도를 개선했습니다.</li>
<li>음운론적 이형태 통합여부를 선택할 수 있도록 옵션을 추가했습니다.</li>
</ul>
</li>
<li>
<p>0.6.5 (2019-06-22)</p>
</li>
<li>
<p>0.6.4 (2019-06-09)</p>
</li>
<li>
<p>0.6.3 (2019-04-14)</p>
<ul>
<li>예외를 좀 더 정교하게 잡아내도록 수정했습니다.</li>
<li>형태소 분석을 바로 테스트해볼 수 있도록 모듈에 대화형 인터페이스를 추가했습니다.</li>
</ul>
</li>
<li>
<p>0.6.1 (2019-03-26)</p>
</li>
<li>
<p>0.6.0 (2018-12-04)</p>
<ul>
<li>형태소 검색 알고리즘 최적화로 분석 속도가 향상되었습니다.</li>
<li>전반적인 정확도가 상승되었습니다.</li>
</ul>
</li>
<li>
<p>0.5.4 (2018-10-11)</p>
</li>
<li>
<p>0.5.2 (2018-09-29)</p>
</li>
<li>
<p>0.5.0 (2018-09-16)</p>
<ul>
<li>Python 모듈 지원이 추가되었습니다.</li>
</ul>
</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ./documentation.rst
&#34;&#34;&#34;
from _kiwipiepy import *
from enum import IntEnum

class Option(IntEnum):
    &#34;&#34;&#34;
    Kiwi 인스턴스 생성 시 사용 가능한 옵션 열거형. 
    bitwise or 연산으로 여러 개 선택하여 사용가능합니다.
    &#34;&#34;&#34;

    LOAD_DEFAULT_DICTIONARY = 1
    &#34;&#34;&#34;
    인스턴스 생성시 자동으로 기본 사전을 불러옵니다. 기본 사전은 위키백과와 나무위키에서 추출된 고유 명사 표제어들로 구성되어 있습니다.
    &#34;&#34;&#34;
    INTEGRATE_ALLOMORPH = 2
    &#34;&#34;&#34;
    음운론적 이형태를 통합하여 출력합니다. /아/와 /어/나 /았/과 /었/ 같이 앞 모음의 양성/음성에 따라 형태가 바뀌는 어미들을 하나로 통합하여 출력합니다.
    &#34;&#34;&#34;
    DEFAULT = 3
    &#34;&#34;&#34;
    Kiwi 생성시의 기본 옵션으로 LOAD_DEFAULT_DICTIONARY | INTEGRATE_ALLOMORPH 와 같습니다.
    &#34;&#34;&#34;

class Match(IntEnum):
    &#34;&#34;&#34;
    .. versionadded:: 0.8.0

    분석 시 특수한 문자열 패턴 중 어떤 것들을 추출할 지 선택할 수 있습니다.
    bitwise or 연산으로 여러 개 선택하여 사용가능합니다.
    &#34;&#34;&#34;
    URL = 1
    &#34;&#34;&#34;
    인터넷 주소 형태의 텍스트를 W_URL이라는 태그로 추출합니다.
    &#34;&#34;&#34;
    EMAIL = 2
    &#34;&#34;&#34;
    이메일 주소 형태의 텍스트를 W_EMAIL이라는 태그로 추출합니다.
    &#34;&#34;&#34;
    HASHTAG = 4
    &#34;&#34;&#34;
    해시태그(#해시태그) 형태의 텍스트를 W_HASHTAG라는 태그로 추출합니다.
    &#34;&#34;&#34;
    ALL = 7
    &#34;&#34;&#34;
    URL, EMAIL, HASHTAG를 모두 사용합니다.
    &#34;&#34;&#34;

del IntEnum</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kiwipiepy.Kiwi"><code class="flex name class">
<span>class <span class="ident">Kiwi</span></span>
<span>(</span><span>self, num_workers=0, model_path='./', options=Option.DEFAULT)</span>
</code></dt>
<dd>
<section class="desc"><p>Kiwi 클래스는 실제 형태소 분석을 수행하는 kiwipiepy 모듈의 핵심 클래스입니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_workers</code></strong> :&ensp;<code>int</code></dt>
<dd>내부적으로 멀티스레딩에 사용할 스레드 개수. 0으로 설정시 시스템 내 가용한 모든 코어 개수만큼 스레드가 생성됩니다.
멀티스레딩은 extract 계열 함수에서 단어 후보를 탐색할 때와 perform, async_analyze 함수 및 reader/receiver를 사용한 analyze 함수에서만 사용되며,
단순 analyze는 단일스레드에서 돌아갑니다.</dd>
<dt><strong><code>model_path</code></strong> :&ensp;<code>str</code></dt>
<dd>읽어들일 모델 파일의 경로. 모델 파일의 위치를 옮긴 경우 이 값을 지정해주어야 합니다.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>int</code></dt>
<dd>Kiwi 생성시의 옵션을 설정합니다. 옵션에 대해서는 <a title="kiwipiepy.Option" href="#kiwipiepy.Option"><code>Option</code></a>을 확인하십시오.</dd>
</dl></section>
<h3>Methods</h3>
<dl>
<dt id="kiwipiepy.Kiwi.addUserWord"><code class="name flex">
<span>def <span class="ident">addUserWord</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>&ndash;</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;0.7.6</p>
</div>
<p>PEP8 규약을 따라 <a title="kiwipiepy.Kiwi.add_user_word" href="#kiwipiepy.Kiwi.add_user_word"><code>Kiwi.add_user_word()</code></a>를 사용하는 것을 권장합니다.</p></section>
</dd>
<dt id="kiwipiepy.Kiwi.add_user_word"><code class="name flex">
<span>def <span class="ident">add_user_word</span></span>(<span>self, word, tag='NNP', score=0)</span>
</code></dt>
<dd>
<section class="desc"><p>현재 모델에 사용자 정의 단어를 추가합니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>word</code></strong> :&ensp;<code>str</code></dt>
<dd>추가할 단어</dd>
<dt><strong><code>tag</code></strong> :&ensp;<code>str</code></dt>
<dd>추가할 단어의 품사 태그</dd>
<dt><strong><code>score</code></strong> :&ensp;<code>float</code></dt>
<dd>추가할 단어의 가중치 점수.
해당 형태에 부합하는 형태소 조합이 여러 개가 있는 경우, 이 점수가 높을 단어가 더 우선권을 가집니다.</dd>
</dl></section>
</dd>
<dt id="kiwipiepy.Kiwi.analyze"><code class="name flex">
<span>def <span class="ident">analyze</span></span>(<span>self, text, top_n=1, match_options=Match.ALL)</span>
</code></dt>
<dd>
<section class="desc"><p>형태소 분석을 실시합니다. 이 분석은 단일 스레드에서 진행됩니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>분석할 문자열입니다.</dd>
<dt><strong><code>top_n</code></strong> :&ensp;<code>int</code></dt>
<dd>분석 결과 후보를 상위 몇 개까지 생성할 지 설정합니다.</dd>
<dt><strong><code>match_options</code></strong> :&ensp;<code>int</code></dt>
<dd>
<div class="admonition versionadded">
<p class="admonition-title">Added in version:&ensp;0.8.0</p>
</div>
<p>추출한 특수 문자열 패턴을 지정합니다. <a title="kiwipiepy.Match" href="#kiwipiepy.Match"><code>Match</code></a>의 조합으로 설정할 수 있습니다.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>List</code>[<code>Tuple</code>[<code>List</code>[<code>Tuple</code>[<code>str</code>, <code>str</code>, <code>int</code>, <code>int</code>]], <code>float</code>]]</dt>
<dd>분석 결과는 최대 <code>top_n</code>개 길이의 리스트로 반환됩니다. 리스트의 각 항목은 <code>(분석 결과, 분석 점수)</code>로 구성된 튜플입니다.
<code>분석 결과</code>는 <code>(형태소, 품사태그, 시작 위치, 문자열 길이)</code> 튜플의 리스트로 구성됩니다.</dd>
</dl>
<p>또한 이 함수는 또 다른 호출 방법을 가지고 있습니다. <code>text</code>를 인자로 직접 넘겨주는 대신 분석할 문자열을 생성할 함수와 분석 결과를 받을 함수를 지정해줄 수 있습니다.</p>
<p><code>analyze(self, reader, receiver, top_n=1, match_options=kiwipiepy.Match.ALL)</code></p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>reader</code></strong> :&ensp;<code>Callable</code>[<code>int</code>, <code>str</code>]</dt>
<dd>분석할 문자열을 읽어들이는 호출 가능한 객체입니다.</dd>
<dt><strong><code>receiver</code></strong> :&ensp;<code>Callable</code>[[<code>int</code>, <code>Any</code>], <code>None</code>]</dt>
<dd>분석된 결과물을 받아들이는 호출 가능한 객체입니다.
첫번째 인자는 분석 결과의 인덱스 번호이며, 두번째 인자는 분석 결과입니다. 분석 결과는 위의 반환값과 동일한 형태입니다.</dd>
<dt><strong><code>top_n</code></strong> :&ensp;<code>int</code></dt>
<dd>분석 결과 후보를 상위 몇 개까지 생성할 지 설정합니다.</dd>
<dt><strong><code>match_options</code></strong> :&ensp;<code>int</code></dt>
<dd>
<div class="admonition versionadded">
<p class="admonition-title">Added in version:&ensp;0.8.0</p>
</div>
<p>추출한 특수 문자열 패턴을 지정합니다. <a title="kiwipiepy.Match" href="#kiwipiepy.Match"><code>Match</code></a>의 조합으로 설정할 수 있습니다.</p>
</dd>
</dl>
<h2 id="returns_1">Returns</h2>
<dl>
<dt><strong><code>none</code></strong> :&ensp;<code>None</code></dt>
<dd>이 경우는 분석 결과를 반환하지 않습니다. 분석 결과는 receiver에서 지정한 호출 가능한 객체에게 전달됩니다.</dd>
</dl></section>
</dd>
<dt id="kiwipiepy.Kiwi.async_analyze"><code class="name flex">
<span>def <span class="ident">async_analyze</span></span>(<span>self, text, top_n=1, match_options=Match.ALL)</span>
</code></dt>
<dd>
<section class="desc"><div class="admonition versionadded">
<p class="admonition-title">Added in version:&ensp;0.7.6</p>
</div>
<p>형태소 분석을 비동기로 실행합니다. 이 메소드를 호출하면 Kiwi는 내부적으로 할당된 스레드에 작업을 할당하고, Python에는 결과물을 받을 수 있는 객체를 돌려줍니다.
따라서 Python 코드에서 멀티스레딩을 지원하지 않아도 이 메소드를 여러번 호출함으로써 멀티스레드 분석이 가능합니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>분석할 문자열입니다.</dd>
<dt><strong><code>top_n</code></strong> :&ensp;<code>int</code></dt>
<dd>분석 결과 후보를 상위 몇 개까지 생성할 지 설정합니다.</dd>
<dt><strong><code>match_options</code></strong> :&ensp;<code>int</code></dt>
<dd>
<div class="admonition versionadded">
<p class="admonition-title">Added in version:&ensp;0.8.0</p>
</div>
<p>추출한 특수 문자열 패턴을 지정합니다. <a title="kiwipiepy.Match" href="#kiwipiepy.Match"><code>Match</code></a>의 조합으로 설정할 수 있습니다.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>future</code></strong> :&ensp;<code>Callable</code>[[], <code>Any</code>]</dt>
<dd>결과값을 생성하는 호출가능한 객체입니다.
이 결과값을 호출하면 내부 작업 스레드에서 분석이 완료되었다면 즉시 그 결과를 반환하고, 아직 분석이 진행중이라면 완료될때까지 대기합니다.
이 객체는 단 한 번만 호출할 수 있습니다.
이 객체의 호출 반환값은 <a title="kiwipiepy.Kiwi.analyze" href="#kiwipiepy.Kiwi.analyze"><code>Kiwi.analyze()</code></a>의 반환값과 동일한 형태입니다.</dd>
</dl></section>
</dd>
<dt id="kiwipiepy.Kiwi.extractAddWords"><code class="name flex">
<span>def <span class="ident">extractAddWords</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>&ndash;</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;0.7.6</p>
</div>
<p>PEP8 규약을 따라 <a title="kiwipiepy.Kiwi.extract_add_words" href="#kiwipiepy.Kiwi.extract_add_words"><code>Kiwi.extract_add_words()</code></a>를 사용하는 것을 권장합니다.</p></section>
</dd>
<dt id="kiwipiepy.Kiwi.extractFilterWords"><code class="name flex">
<span>def <span class="ident">extractFilterWords</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>&ndash;</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;0.7.6</p>
</div>
<p>PEP8 규약을 따라 <a title="kiwipiepy.Kiwi.extract_filter_words" href="#kiwipiepy.Kiwi.extract_filter_words"><code>Kiwi.extract_filter_words()</code></a>를 사용하는 것을 권장합니다.</p></section>
</dd>
<dt id="kiwipiepy.Kiwi.extractWords"><code class="name flex">
<span>def <span class="ident">extractWords</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>&ndash;</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;0.7.6</p>
</div>
<p>PEP8 규약을 따라 <a title="kiwipiepy.Kiwi.extract_words" href="#kiwipiepy.Kiwi.extract_words"><code>Kiwi.extract_words()</code></a>를 사용하는 것을 권장합니다.</p></section>
</dd>
<dt id="kiwipiepy.Kiwi.extract_add_words"><code class="name flex">
<span>def <span class="ident">extract_add_words</span></span>(<span>self, reader, min_cnt=10, max_word_len=10, min_score=0.25, pos_score=-3)</span>
</code></dt>
<dd>
<section class="desc"><p>말뭉치로부터 새로운 단어를 추출하고 새로운 명사에 적합한 결과들만 추려냅니다. 그리고 그 결과를 현재 모델에 자동으로 추가합니다.
이 메소드는 <a title="kiwipiepy.Kiwi.prepare" href="#kiwipiepy.Kiwi.prepare"><code>Kiwi.prepare()</code></a>를 호출하기 전에만 사용 가능합니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reader</code></strong> :&ensp;<code>Callable</code>[<code>int</code>, <code>str</code>]</dt>
<dd>분석할 문자열을 읽어들이는 호출 가능한 객체입니다.</dd>
<dt><strong><code>min_cnt</code></strong> :&ensp;<code>int</code></dt>
<dd>추출할 단어의 최소 출현 빈도입니다. 이 빈도보다 적게 등장한 문자열은 단어 후보에서 제외됩니다.</dd>
<dt><strong><code>max_word_len</code></strong> :&ensp;<code>int</code></dt>
<dd>추출할 단어 후보의 최대 길이입니다. 이 길이보다 긴 단어 후보는 탐색되지 않습니다.</dd>
<dt><strong><code>min_score</code></strong> :&ensp;<code>float</code></dt>
<dd>단어 후보의 최소 점수입니다. 이 점수보다 낮은 단어 후보는 고려되지 않습니다.
이 값을 낮출수록 단어가 아닌 형태가 추출될 가능성이 높아지고, 반대로 이 값을 높일 수록 추출되는 단어의 개수가 줄어들므로 적절한 수치로 설정할 필요가 있습니다.</dd>
<dt><strong><code>pos_score</code></strong> :&ensp;<code>float</code></dt>
<dd>단어 후보의 품사 점수입니다. 품사 점수가 이 값보다 낮은 경우 후보에서 제외됩니다.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>List</code>[<code>Tuple</code>[<code>str</code>, <code>float</code>, <code>int</code>, <code>float</code>]]</dt>
<dd>추출된 단어후보의 목록을 반환합니다. 리스트의 각 항목은 (단어 형태, 최종 점수, 출현 빈도, 품사 점수)로 구성된 튜플입니다.</dd>
</dl></section>
</dd>
<dt id="kiwipiepy.Kiwi.extract_filter_words"><code class="name flex">
<span>def <span class="ident">extract_filter_words</span></span>(<span>self, reader, min_cnt=10, max_word_len=10, min_score=0.25, pos_score=-3)</span>
</code></dt>
<dd>
<section class="desc"><p>말뭉치로부터 새로운 단어를 추출하고 새로운 명사에 적합한 결과들만 추려냅니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reader</code></strong> :&ensp;<code>Callable</code>[<code>int</code>, <code>str</code>]</dt>
<dd>분석할 문자열을 읽어들이는 호출 가능한 객체입니다.</dd>
<dt><strong><code>min_cnt</code></strong> :&ensp;<code>int</code></dt>
<dd>추출할 단어의 최소 출현 빈도입니다. 이 빈도보다 적게 등장한 문자열은 단어 후보에서 제외됩니다.</dd>
<dt><strong><code>max_word_len</code></strong> :&ensp;<code>int</code></dt>
<dd>추출할 단어 후보의 최대 길이입니다. 이 길이보다 긴 단어 후보는 탐색되지 않습니다.</dd>
<dt><strong><code>min_score</code></strong> :&ensp;<code>float</code></dt>
<dd>단어 후보의 최소 점수입니다. 이 점수보다 낮은 단어 후보는 고려되지 않습니다.
이 값을 낮출수록 단어가 아닌 형태가 추출될 가능성이 높아지고, 반대로 이 값을 높일 수록 추출되는 단어의 개수가 줄어들므로 적절한 수치로 설정할 필요가 있습니다.</dd>
<dt><strong><code>pos_score</code></strong> :&ensp;<code>float</code></dt>
<dd>단어 후보의 품사 점수입니다. 품사 점수가 이 값보다 낮은 경우 후보에서 제외됩니다.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>List</code>[<code>Tuple</code>[<code>str</code>, <code>float</code>, <code>int</code>, <code>float</code>]]</dt>
<dd>추출된 단어후보의 목록을 반환합니다. 리스트의 각 항목은 (단어 형태, 최종 점수, 출현 빈도, 품사 점수)로 구성된 튜플입니다.</dd>
</dl></section>
</dd>
<dt id="kiwipiepy.Kiwi.extract_words"><code class="name flex">
<span>def <span class="ident">extract_words</span></span>(<span>self, reader, min_cnt=10, max_word_len=10, min_score=0.25)</span>
</code></dt>
<dd>
<section class="desc"><p>말뭉치로부터 새로운 단어를 추출합니다.
이 기능은 <a href="https://github.com/lovit/soynlp">https://github.com/lovit/soynlp</a> 의 Word Extraction 기법을 바탕으로 하고 있으며,
이에 문자열 기반의 명사 확률을 조합하여 명사일 것으로 예측되는 단어만 추출합니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reader</code></strong> :&ensp;<code>Callable</code>[<code>int</code>, <code>str</code>]</dt>
<dd>분석할 문자열을 읽어들이는 호출 가능한 객체입니다.</dd>
<dt><strong><code>min_cnt</code></strong> :&ensp;<code>int</code></dt>
<dd>추출할 단어의 최소 출현 빈도입니다. 이 빈도보다 적게 등장한 문자열은 단어 후보에서 제외됩니다.</dd>
<dt><strong><code>max_word_len</code></strong> :&ensp;<code>int</code></dt>
<dd>추출할 단어 후보의 최대 길이입니다. 이 길이보다 긴 단어 후보는 탐색되지 않습니다.</dd>
<dt><strong><code>min_score</code></strong> :&ensp;<code>float</code></dt>
<dd>단어 후보의 최소 점수입니다. 이 점수보다 낮은 단어 후보는 고려되지 않습니다.
이 값을 낮출수록 단어가 아닌 형태가 추출될 가능성이 높아지고, 반대로 이 값을 높일 수록 추출되는 단어의 개수가 줄어들므로 적절한 수치로 설정할 필요가 있습니다.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>List</code>[<code>Tuple</code>[<code>str</code>, <code>float</code>, <code>int</code>, <code>float</code>]]</dt>
<dd>추출된 단어후보의 목록을 반환합니다. 리스트의 각 항목은 (단어 형태, 최종 점수, 출현 빈도, 품사 점수)로 구성된 튜플입니다.</dd>
</dl></section>
</dd>
<dt id="kiwipiepy.Kiwi.get_option"><code class="name flex">
<span>def <span class="ident">get_option</span></span>(<span>self, option)</span>
</code></dt>
<dd>
<section class="desc"><p>현재 모델의 설정값을 가져옵니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>option</code></strong> :&ensp;<a title="kiwipiepy.Option" href="#kiwipiepy.Option"><code>Option</code></a></dt>
<dd>검사할 옵션의 열거값. 현재는 <a title="kiwipiepy.Option.INTEGRATE_ALLOMORPH" href="#kiwipiepy.Option.INTEGRATE_ALLOMORPH"><code>Option.INTEGRATE_ALLOMORPH</code></a>만 지원합니다.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>해당 옵션이 설정되어 있는 경우 1, 아닌 경우 0을 반환합니다.</dd>
</dl></section>
</dd>
<dt id="kiwipiepy.Kiwi.loadUserDictionary"><code class="name flex">
<span>def <span class="ident">loadUserDictionary</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>&ndash;</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;0.7.6</p>
</div>
<p>PEP8 규약을 따라 <a title="kiwipiepy.Kiwi.load_user_dictionary" href="#kiwipiepy.Kiwi.load_user_dictionary"><code>Kiwi.load_user_dictionary()</code></a>를 사용하는 것을 권장합니다.</p></section>
</dd>
<dt id="kiwipiepy.Kiwi.load_user_dictionary"><code class="name flex">
<span>def <span class="ident">load_user_dictionary</span></span>(<span>self, dict_path)</span>
</code></dt>
<dd>
<section class="desc"><p>사용자 정의 사전을 읽어옵니다. 사용자 정의 사전 파일은 UTF-8로 인코딩된 텍스트 파일이어야 합니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dict_path</code></strong> :&ensp;<code>str</code></dt>
<dd>사용자 정의 사전 파일의 경로</dd>
</dl></section>
</dd>
<dt id="kiwipiepy.Kiwi.perform"><code class="name flex">
<span>def <span class="ident">perform</span></span>(<span>self, reader, receiver, top_n=1, match_options=Match.ALL, min_cnt=10, max_word_len=10, min_score=0.25, pos_score=-3)</span>
</code></dt>
<dd>
<section class="desc"><p>현재 모델의 사본을 만들어
<a title="kiwipiepy.Kiwi.extract_add_words" href="#kiwipiepy.Kiwi.extract_add_words"><code>Kiwi.extract_add_words()</code></a>메소드로 말뭉치에서 단어를 추출하여 추가하고, <a title="kiwipiepy.Kiwi.analyze" href="#kiwipiepy.Kiwi.analyze"><code>Kiwi.analyze()</code></a>로 형태소 분석을 실시합니다.
이 메소드 호출 후 모델의 사본은 파괴되므로, 말뭉치에서 추출된 단어들은 다시 모델에서 제거되고, 메소드 실행 전과 동일한 상태로 돌아갑니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reader</code></strong> :&ensp;<code>Callable</code>[<code>int</code>, <code>str</code>]</dt>
<dd>분석할 문자열을 읽어들이는 호출 가능한 객체입니다.</dd>
<dt><strong><code>receiver</code></strong> :&ensp;<code>Callable</code>[[<code>int</code>, <code>Any</code>], <code>None</code>]</dt>
<dd>분석된 결과물을 받아들이는 호출 가능한 객체입니다.
첫번째 인자는 분석 결과의 인덱스 번호이며, 두번째 인자는 분석 결과입니다. 분석 결과는 <a title="kiwipiepy.Kiwi.analyze" href="#kiwipiepy.Kiwi.analyze"><code>Kiwi.analyze()</code></a>의 반환값과 동일한 형태입니다.</dd>
<dt><strong><code>top_n</code></strong> :&ensp;<code>int</code></dt>
<dd>분석 결과 후보를 상위 몇 개까지 생성할 지 설정합니다.</dd>
<dt><strong><code>match_options</code></strong> :&ensp;<code>int</code></dt>
<dd>
<div class="admonition versionadded">
<p class="admonition-title">Added in version:&ensp;0.8.0</p>
</div>
<p>추출한 특수 문자열 패턴을 지정합니다. <a title="kiwipiepy.Match" href="#kiwipiepy.Match"><code>Match</code></a>의 조합으로 설정할 수 있습니다.</p>
</dd>
<dt><strong><code>min_cnt</code></strong> :&ensp;<code>int</code></dt>
<dd>추출할 단어의 최소 출현 빈도입니다. 이 빈도보다 적게 등장한 문자열은 단어 후보에서 제외됩니다.</dd>
<dt><strong><code>max_word_len</code></strong> :&ensp;<code>int</code></dt>
<dd>추출할 단어 후보의 최대 길이입니다. 이 길이보다 긴 단어 후보는 탐색되지 않습니다.</dd>
<dt><strong><code>min_score</code></strong> :&ensp;<code>float</code></dt>
<dd>단어 후보의 최소 점수입니다. 이 점수보다 낮은 단어 후보는 고려되지 않습니다.</dd>
<dt><strong><code>pos_score</code></strong> :&ensp;<code>float</code></dt>
<dd>단어 후보의 품사 점수입니다. 품사 점수가 이 값보다 낮은 경우 후보에서 제외됩니다.</dd>
</dl></section>
</dd>
<dt id="kiwipiepy.Kiwi.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>현재 모델을 최적화하여 형태소 분석을 수행할 수 있도록 준비합니다.
이 메소드를 호출한 이후로는 <a title="kiwipiepy.Kiwi.add_user_word" href="#kiwipiepy.Kiwi.add_user_word"><code>Kiwi.add_user_word()</code></a>, <a title="kiwipiepy.Kiwi.load_user_dictionary" href="#kiwipiepy.Kiwi.load_user_dictionary"><code>Kiwi.load_user_dictionary()</code></a>,
<a title="kiwipiepy.Kiwi.extract_add_words" href="#kiwipiepy.Kiwi.extract_add_words"><code>Kiwi.extract_add_words()</code></a>
등을 사용하여 사용자 사전에 단어를 추가할 수 없습니다.</p></section>
</dd>
<dt id="kiwipiepy.Kiwi.setCutOffThreshold"><code class="name flex">
<span>def <span class="ident">setCutOffThreshold</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>&ndash;</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;0.7.6</p>
</div>
<p>PEP8 규약을 따라 <a title="kiwipiepy.Kiwi.set_cutoff_threshold" href="#kiwipiepy.Kiwi.set_cutoff_threshold"><code>Kiwi.set_cutoff_threshold()</code></a>를 사용하는 것을 권장합니다.</p></section>
</dd>
<dt id="kiwipiepy.Kiwi.set_cutoff_threshold"><code class="name flex">
<span>def <span class="ident">set_cutoff_threshold</span></span>(<span>self, threshold)</span>
</code></dt>
<dd>
<section class="desc"><p>Beam 탐색 시 미리 제거할 후보의 점수 차를 설정합니다. 이 값이 클 수록 더 많은 후보를 탐색하게 되므로 분석 속도가 느려지지만 정확도가 올라갑니다.
반대로 이 값을 낮추면 더 적은 후보를 탐색하여 속도를 빨라지지만 정확도는 낮아집니다. 초기값은 8입니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>0 보다 큰 실수</dd>
</dl></section>
</dd>
<dt id="kiwipiepy.Kiwi.set_option"><code class="name flex">
<span>def <span class="ident">set_option</span></span>(<span>self, option, value)</span>
</code></dt>
<dd>
<section class="desc"><p>현재 모델의 설정값을 변경합니다.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>option</code></strong> :&ensp;<a title="kiwipiepy.Option" href="#kiwipiepy.Option"><code>Option</code></a></dt>
<dd>변경할 옵션의 열거값. 현재는 <a title="kiwipiepy.Option.INTEGRATE_ALLOMORPH" href="#kiwipiepy.Option.INTEGRATE_ALLOMORPH"><code>Option.INTEGRATE_ALLOMORPH</code></a>만 지원합니다.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>0으로 설정할 경우 해당 옵션을 해제, 0이 아닌 값으로 설정할 경우 해당 옵션을 설정합니다.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="kiwipiepy.Match"><code class="flex name class">
<span>class <span class="ident">Match</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><div class="admonition versionadded">
<p class="admonition-title">Added in version:&ensp;0.8.0</p>
</div>
<p>분석 시 특수한 문자열 패턴 중 어떤 것들을 추출할 지 선택할 수 있습니다.
bitwise or 연산으로 여러 개 선택하여 사용가능합니다.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Match(IntEnum):
    &#34;&#34;&#34;
    .. versionadded:: 0.8.0

    분석 시 특수한 문자열 패턴 중 어떤 것들을 추출할 지 선택할 수 있습니다.
    bitwise or 연산으로 여러 개 선택하여 사용가능합니다.
    &#34;&#34;&#34;
    URL = 1
    &#34;&#34;&#34;
    인터넷 주소 형태의 텍스트를 W_URL이라는 태그로 추출합니다.
    &#34;&#34;&#34;
    EMAIL = 2
    &#34;&#34;&#34;
    이메일 주소 형태의 텍스트를 W_EMAIL이라는 태그로 추출합니다.
    &#34;&#34;&#34;
    HASHTAG = 4
    &#34;&#34;&#34;
    해시태그(#해시태그) 형태의 텍스트를 W_HASHTAG라는 태그로 추출합니다.
    &#34;&#34;&#34;
    ALL = 7
    &#34;&#34;&#34;
    URL, EMAIL, HASHTAG를 모두 사용합니다.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kiwipiepy.Match.ALL"><code class="name">var <span class="ident">ALL</span></code></dt>
<dd>
<section class="desc"><p>URL, EMAIL, HASHTAG를 모두 사용합니다.</p></section>
</dd>
<dt id="kiwipiepy.Match.EMAIL"><code class="name">var <span class="ident">EMAIL</span></code></dt>
<dd>
<section class="desc"><p>이메일 주소 형태의 텍스트를 W_EMAIL이라는 태그로 추출합니다.</p></section>
</dd>
<dt id="kiwipiepy.Match.HASHTAG"><code class="name">var <span class="ident">HASHTAG</span></code></dt>
<dd>
<section class="desc"><p>해시태그(#해시태그) 형태의 텍스트를 W_HASHTAG라는 태그로 추출합니다.</p></section>
</dd>
<dt id="kiwipiepy.Match.URL"><code class="name">var <span class="ident">URL</span></code></dt>
<dd>
<section class="desc"><p>인터넷 주소 형태의 텍스트를 W_URL이라는 태그로 추출합니다.</p></section>
</dd>
</dl>
</dd>
<dt id="kiwipiepy.Option"><code class="flex name class">
<span>class <span class="ident">Option</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Kiwi 인스턴스 생성 시 사용 가능한 옵션 열거형.
bitwise or 연산으로 여러 개 선택하여 사용가능합니다.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Option(IntEnum):
    &#34;&#34;&#34;
    Kiwi 인스턴스 생성 시 사용 가능한 옵션 열거형. 
    bitwise or 연산으로 여러 개 선택하여 사용가능합니다.
    &#34;&#34;&#34;

    LOAD_DEFAULT_DICTIONARY = 1
    &#34;&#34;&#34;
    인스턴스 생성시 자동으로 기본 사전을 불러옵니다. 기본 사전은 위키백과와 나무위키에서 추출된 고유 명사 표제어들로 구성되어 있습니다.
    &#34;&#34;&#34;
    INTEGRATE_ALLOMORPH = 2
    &#34;&#34;&#34;
    음운론적 이형태를 통합하여 출력합니다. /아/와 /어/나 /았/과 /었/ 같이 앞 모음의 양성/음성에 따라 형태가 바뀌는 어미들을 하나로 통합하여 출력합니다.
    &#34;&#34;&#34;
    DEFAULT = 3
    &#34;&#34;&#34;
    Kiwi 생성시의 기본 옵션으로 LOAD_DEFAULT_DICTIONARY | INTEGRATE_ALLOMORPH 와 같습니다.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kiwipiepy.Option.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<section class="desc"><p>Kiwi 생성시의 기본 옵션으로 LOAD_DEFAULT_DICTIONARY | INTEGRATE_ALLOMORPH 와 같습니다.</p></section>
</dd>
<dt id="kiwipiepy.Option.INTEGRATE_ALLOMORPH"><code class="name">var <span class="ident">INTEGRATE_ALLOMORPH</span></code></dt>
<dd>
<section class="desc"><p>음운론적 이형태를 통합하여 출력합니다. /아/와 /어/나 /았/과 /었/ 같이 앞 모음의 양성/음성에 따라 형태가 바뀌는 어미들을 하나로 통합하여 출력합니다.</p></section>
</dd>
<dt id="kiwipiepy.Option.LOAD_DEFAULT_DICTIONARY"><code class="name">var <span class="ident">LOAD_DEFAULT_DICTIONARY</span></code></dt>
<dd>
<section class="desc"><p>인스턴스 생성시 자동으로 기본 사전을 불러옵니다. 기본 사전은 위키백과와 나무위키에서 추출된 고유 명사 표제어들로 구성되어 있습니다.</p></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#kiwipiepy">Kiwipiepy란?</a><ul>
<li><a href="#_1">시작하기</a></li>
<li><a href="#_2">예제</a></li>
<li><a href="#_3">사용자 정의 사전 포맷</a></li>
<li><a href="#_4">데모</a></li>
<li><a href="#_5">라이센스</a></li>
<li><a href="#_6">오류 제보</a></li>
<li><a href="#_7">역사</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kiwipiepy.Kiwi" href="#kiwipiepy.Kiwi">Kiwi</a></code></h4>
<ul class="">
<li><code><a title="kiwipiepy.Kiwi.addUserWord" href="#kiwipiepy.Kiwi.addUserWord">addUserWord</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.add_user_word" href="#kiwipiepy.Kiwi.add_user_word">add_user_word</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.analyze" href="#kiwipiepy.Kiwi.analyze">analyze</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.async_analyze" href="#kiwipiepy.Kiwi.async_analyze">async_analyze</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.extractAddWords" href="#kiwipiepy.Kiwi.extractAddWords">extractAddWords</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.extractFilterWords" href="#kiwipiepy.Kiwi.extractFilterWords">extractFilterWords</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.extractWords" href="#kiwipiepy.Kiwi.extractWords">extractWords</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.extract_add_words" href="#kiwipiepy.Kiwi.extract_add_words">extract_add_words</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.extract_filter_words" href="#kiwipiepy.Kiwi.extract_filter_words">extract_filter_words</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.extract_words" href="#kiwipiepy.Kiwi.extract_words">extract_words</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.get_option" href="#kiwipiepy.Kiwi.get_option">get_option</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.loadUserDictionary" href="#kiwipiepy.Kiwi.loadUserDictionary">loadUserDictionary</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.load_user_dictionary" href="#kiwipiepy.Kiwi.load_user_dictionary">load_user_dictionary</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.perform" href="#kiwipiepy.Kiwi.perform">perform</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.prepare" href="#kiwipiepy.Kiwi.prepare">prepare</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.setCutOffThreshold" href="#kiwipiepy.Kiwi.setCutOffThreshold">setCutOffThreshold</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.set_cutoff_threshold" href="#kiwipiepy.Kiwi.set_cutoff_threshold">set_cutoff_threshold</a></code></li>
<li><code><a title="kiwipiepy.Kiwi.set_option" href="#kiwipiepy.Kiwi.set_option">set_option</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kiwipiepy.Match" href="#kiwipiepy.Match">Match</a></code></h4>
<ul class="">
<li><code><a title="kiwipiepy.Match.ALL" href="#kiwipiepy.Match.ALL">ALL</a></code></li>
<li><code><a title="kiwipiepy.Match.EMAIL" href="#kiwipiepy.Match.EMAIL">EMAIL</a></code></li>
<li><code><a title="kiwipiepy.Match.HASHTAG" href="#kiwipiepy.Match.HASHTAG">HASHTAG</a></code></li>
<li><code><a title="kiwipiepy.Match.URL" href="#kiwipiepy.Match.URL">URL</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kiwipiepy.Option" href="#kiwipiepy.Option">Option</a></code></h4>
<ul class="">
<li><code><a title="kiwipiepy.Option.DEFAULT" href="#kiwipiepy.Option.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="kiwipiepy.Option.INTEGRATE_ALLOMORPH" href="#kiwipiepy.Option.INTEGRATE_ALLOMORPH">INTEGRATE_ALLOMORPH</a></code></li>
<li><code><a title="kiwipiepy.Option.LOAD_DEFAULT_DICTIONARY" href="#kiwipiepy.Option.LOAD_DEFAULT_DICTIONARY">LOAD_DEFAULT_DICTIONARY</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>